function [] = crg_demo_gen_refline()
% CRG_DEMO_GEN_REFLINE CRG demo to generate a (smooth) refline crg file.
%   CRG_DEMO_GEN_REFLINE() demonstrates how a smooth refline can be
%   generated. It uses one of the OpenCRG data samples as measurement
%   data source.
%   In this first step, it extracts xy point pair measurements out of it,
%   finds a smooth ppform for the refline, and generates a refline only CRG
%   data set, which will be further used by CRG_DEMO_GEN_SURFACE.
%
%   Example:
%   crg_demo_gen_refline    runs this demo to generate "refline.crg"
%
%   See also CRG_INTRO.

% *****************************************************************
% ASAM OpenCRG Matlab API
%
% OpenCRG version:           1.2.0
%
% package:               demo
% file name:             crg_demo_gen_refline.m
% author:                ASAM e.V.
%
%
% C by ASAM e.V., 2020
% Any use is limited to the scope described in the license terms.
% The license terms can be viewed at www.asam.net/license
%
% More Information on ASAM OpenCRG can be found here:
% https://www.asam.net/standards/detail/opencrg/
%
% *****************************************************************

%% use CRG demo data set as measurement data

crgmeas = crg_read('../crg-bin/country_road.crg');

%% generate (noisy) midpoint measurements of it

nu = 5000;          % number of measurements
xnoise = 0.05;      % measurement noise
ynoise = 0.05;      % measurement noise

puv = [linspace(crgmeas.head.ubeg, crgmeas.head.uend, nu)' zeros(nu, 1)];
pxy = crg_eval_uv2xy(crgmeas, puv);

pxy(:,1) = pxy(:,1) + xnoise*randn(nu,1);   % add x noise
pxy(:,2) = pxy(:,2) + ynoise*randn(nu,1);   % add y noise

%% set processing parameters and options

lshow = 1;   % show results [0 1]
uinc = 0.01; % longitudinal grid spacing

% find the perfect spline - this is much dependant on the data
%
% splinefit increment: defines approximate length of spline segments used
% to represent the (noisy) refline data
% opts.sf_inct =  2;    % define too short segments
  opts.sf_incr =  5;    % optimal choice for this rather straight road
% opts.sf_inct = 10;    % define too long segments
%
% splsmooth smoothing parameter: 1:no smoothing, 0:regression line
% opts.ss_spar = 0.05;  % refline too rough
  opts.ss_spar = 0.005; % optimal smoothing
% opts.ss_spar = 0.0005;% refline too smooth, refline cuts the corners

%% generate (hopefully) smooth ppform of refline

ppxy = crg_gen_pxy2ppxy(pxy, opts);

%% build the new refline

[crgrefl err] = crg_gen_ppxy2phi(ppxy, uinc);

if err > 1e-7
    error('CRG:demoError', 'refline forward integration error %d too big!', err)
end

%% add virtual zero elevation grid

crgrefl.z = zeros(length(crgrefl.p)+1, 2, 'single');
crgrefl.v = single(1);
crgrefl=crg_check(crgrefl);

%% add WGS84 lon/lat data (if it's available for the measurements)

% The start and end points of the new refline are in general not the same
% as the start and end points of the measurement data. So we have to
% calculatethe WGS84 lon/lat for the start and end points of the refline
% using two WGS84-XY pairs of the measurement data. In this demo, we can
%  use the WGS84 info of the demo file used as measurement.

pxyrefl = [ ...
    crgrefl.head.xbeg crgrefl.head.ybeg;
    crgrefl.head.xend crgrefl.head.yend];

[wgsrefl, ~] = crg_wgs84_xy2wgs(crgmeas, pxyrefl);

crgrefl.head.nbeg = wgsrefl(1,1);
crgrefl.head.ebeg = wgsrefl(1,2);
crgrefl.head.nend = wgsrefl(2,1);
crgrefl.head.eend = wgsrefl(2,2);

%% check CRG again

crgrefl = crg_check(crgrefl);
if ~isfield(crgrefl, 'ok')
    error('CRG:checkError', 'check of DATA was not completely successful')
end

%% write refline CRG data set

crgrefl.filenm = 'refline.crg';
crgrefl.ct{1}  = sprintf('demo refline generated by %s at %s', mfilename, datestr(now, 31));
crg_write(crgrefl, crgrefl.filenm);

fprintf(1, '\nCRG refline file %s is written.\n', crgrefl.filenm);

%% show what we have got so far ...

if lshow
    crg_show_refpnts_and_refline(crgrefl, pxy);
    crg_wgs84_crg2html(crgrefl, 'refline.html');
    web('refline.html', '-browser');
end
end
